(defun dbg (&rest rest)
  (apply (@ console log) rest)
  (@ rest 0))

(defmacro let2 (bindings &rest forms)
  `((lambda ()
      ,@(loop for (name val) in bindings
              collect `(var ,name ,val))
      ,@forms)))

(defun use-history-state-reducer (state action)
  (with-slots (past present future) state
    (case (@ action type)
      (("UNDO") (create
                 past (chain past (slice 0 (1- (length past))))
                 present (aref past (1- (length past)))
                 future (append (list present) future)))
      (("REDO") (create
                 past (append past (list present))
                 present (aref future 0)
                 future (chain future (slice 1))))
      (("SET")
       (with-slots (new-present) action
         (if (= new-present present)
             state
             (create
              past (append past (list present))
              present new-present
              future (list)))))
      (("CLEAR") (create
                  past (list)
                  present (@ action initial-present)
                  future (list))))))

(defcomponent use-history-state2
    ((initial-present-ref (use-ref initial-present))
     ((state dispatch) (use-reducer use-history-state-reducer
                                    (create
                                     past (list)
                                     present (@ initial-present-ref current)
                                     future (list))))
     (undo (use-callback (lambda ()
                           (dispatch (create type "UNDO")))
                         (list can-undo)))
     (redo (use-callback (lambda ()
                           (dispatch (create type "REDO")))
                         (list can-redo)))
     (set (use-callback (lambda (new-present)
                          (dispatch (create type "SET" new-present new-present)))
                        (list)))
     (clear (use-callback (lambda (new-present)
                            (dispatch (create
                                       type "CLEAR"
                                       initial-present
                                       (if (undefined new-present)
                                           (@ initial-present-ref current)
                                           new-present))))
                          (list))))
  (initial-present)
  (let ((can-undo (not (= (@ state past length) 0)))
        (can-redo (not (= (@ state future length) 0))))
    (create
     state (@ state present)
     set set
     undo undo
     redo redo
     clear clear
     can-undo can-undo
     can-redo can-redo)))

(defun make-rng (seed)
  #'(lambda ()
      (ash (setf seed (mod (+ (* 214013 seed) 2531011) (expt 2 31))) -16)))

(defmacro swap (p1 p2)
  `(setf (list ,p1 ,p2) (list ,p2 ,p1)))

(defmacro -> (initial &rest forms)
  (if (null forms)
      initial
      `(-> ,(list* (caar forms) initial (cdar forms))
           ,@(cdr forms))))

(defmacro with-defaults (slots obj &rest forms)
  (let ((names (loop for slot in slots
                     collect (if (atom slot) slot (car slot))))
        (assigns (loop for slot in slots
                       when (consp slot)
                         collect `(,(car slot)
                                   (if (undefined ,(car slot)) ,(cadr slot) ,(car slot))))))
    `(with-slots ,names ,obj
       (let ,assigns
         ,@forms))))

(defun class-names (&rest names)
  (chain names
         (filter (lambda (x) x))
         (join " ")))

(defun new-deck (seed)
  (let ((hand (list))
        (rng (make-rng seed)))
    (dolist (d (loop for i from 1 to 13 collect i))
      (dolist (s '(clover diamond heart spade))
        (chain hand (push (list s d)))))
    (dotimes (i 52)
      (let ((idx1 (- 51 i))
            (idx2 (mod (funcall rng) (- 52 i)))))
      (swap (aref hand idx1)
            (aref hand idx2)))
    (chain hand (reverse))))

(defun last (list)
  (aref list (1- (@ list length))))

(defun make-tableaus (seed)
  (let ((deck (new-deck seed))
        (tableaus (loop for i from 0 below 8 collect (list))))
    (loop for i from 0 to 51
          for card in deck do
            (chain (aref tableaus (mod i 8)) (push card)))
    tableaus))

(defun suit->index (suit)
  (case suit
    ((spade) 0)
    ((diamond) 1)
    ((clover) 2)
    ((heart) 3)))

(defun card->index (card)
  (destructuring-bind (suit num) card
    (+ num (* 13 (suit->index suit)))))

(defun card->id (card)
  (destructuring-bind (suit num) card
    (+ "card_" suit "_" num)))

(defun card->img (card)
  (destructuring-bind (suit num) card
    (if false
        (+ "1_" suit "_" num "@1x.png")
        (+ "newcards/" suit "_" num ".svg"))))

(defun card->name (card)
  (destructuring-bind (suit num) card
    (+ (cond
         ((= num 1) "Ace")
         ((= num 11) "Jack")
         ((= num 12) "Queen")
         ((= num 13) "King")
         (t num))
       " of "
       (case suit
         ((spade) "Spades")
         ((clover) "Clubs")
         ((diamond) "Diamonds")
         ((heart) "Hearts")))))

(defun id->card (id)
  (let ((parts (chain id (split "_"))))
    (list (aref parts 1)
          (parse-int (aref parts 2)))))

(defun freecell->num (id)
  (aref (chain id (split "_")) 1))

(defun card= (card1 card2)
  (and (equal (aref card1 0) (aref card2 0))
       (equal (aref card1 1) (aref card2 1))))

(defun find-card (card tableaus)
  (let ((col 0) (row 0))
    (loop for tableau in tableaus do
      (loop for maybe-card in tableau
            when (card= card maybe-card)
              do (return-from find-card (list col row))
            do (incf row))
      (incf col)
      (setf row 0))))

;;;;;;;;;;;;;

(defun move-card (state from row to)
  (let* ((tableaus (@ state tableaus))
         (before (chain (aref tableaus from) (slice 0 (1- row))))
         (after (chain (aref tableaus from) (slice (1- row)))))
    (setf (aref tableaus from) before)
    (setf (aref tableaus to) (append (aref tableaus to) after))
    state))

(defun insert-card (state arr into card)
  (let* ((tableaus (aref state arr)))
    (chain (aref tableaus into) (push card))
    state))

(defun delete-from-column (state from)
  (let ((tableaus (@ state tableaus)))
    (chain (aref tableaus from) (pop))
    state))

(defun set-freecell (state idx card)
  (let ((freecells (@ state freecells)))
    (setf (aref freecells idx) card)
    state))

(defun clear-freecell (state idx)
  (let ((freecells (@ state freecells)))
    (setf (aref freecells idx) nil)
    state))

(defun auto-foundation (state)
  (flet ((unneeded (card)
           (destructuring-bind (suit num) card
             (when (> num 2)
               (with-slots (tableaus freecells) state
                 (loop for tableau in tableaus do
                   (loop for (other-suit other-num) in tableau
                         when (and (not (= other-suit suit))
                                   (= num (1+ other-num)))
                           do (return-from unneeded false)))
                 (loop for card2 in freecells
                       do (when card2
                            (destructuring-bind (other-suit other-num) card2
                              (when (and (not (= other-suit suit))
                                         (= num (1+ other-num)))
                                (return-from unneeded false)))))))
             true))
         (find-ready ()
           (with-slots (tableaus foundations freecells) state
             (loop for tableau in tableaus
                   for col = 0 then (1+ col)
                   for card = (last tableau)
                   when card
                     do
                        (destructuring-bind (suit num) card
                          (let* ((suit-idx (suit->index suit))
                                 (dropped-on-card (last (aref foundations suit-idx))))
                            (when (and (next-in-suit card dropped-on-card)
                                       (unneeded card))
                              (-> state
                                  (delete-from-column col)
                                  (insert-card 'foundations suit-idx card))
                              (return-from find-ready true)))))

             (loop for card in freecells
                   for cell-idx = 0 then (1+ cell-idx)
                   when card do
                     (destructuring-bind (suit num) card
                       (let* ((suit-idx (suit->index suit))
                              (dropped-on-card (last (aref foundations suit-idx))))
                         (when (and (next-in-suit card dropped-on-card)
                                    (unneeded card))
                           (-> state
                               (clear-freecell cell-idx)
                               (insert-card 'foundations suit-idx card))
                           (return-from find-ready true))))))
           false)))
  (loop while (find-ready))
  state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun without-idx (list idx)
  (chain list (filter (lambda (val arr-idx) (not (= idx arr-idx))))))

(defun emptyp (list)
  (not (@ list length)))

(defun suit-color (suit)
  (case suit
    ((diamond) 'red)
    ((heart) 'red)
    ((spade) 'black)
    ((clover) 'black)))

(defun suitable-droppable (card droppable)
  (destructuring-binds (((suit1 num1) card)
                        ((suit2 num2) droppable))
                       (and (not (= (suit-color suit1) (suit-color suit2)))
                            (= (1- num2) num1))))

(defun next-in-suit (card next)
  (if (not next)
      (= (aref card 1) 1)
      (destructuring-bind (suit1 num1) card
        (destructuring-bind (suit2 num2) next
          (and (= suit1 suit2) (= (1- num1) num2))))))

(defun is-tableau (cards)
  (loop for (c1 c2) on cards
        when (and c2 (not (suitable-droppable c2 c1))) do (return false)
          finally (return true)))

(defun get-offset (el)
  (create left (@ el offset-left)
          top (@ el offset-top)))

(defcomponent -card
    ((dg (use-ref))
     (card-ref (use-ref))
     (companions (use-ref))
     (start-x (use-ref))
     (start-y (use-ref))
     (on-moved-callback (use-ref))
     ((z-index-boosted set-z-index-boosted) (use-state false))
     (_ (use-g-s-a-p
         (lambda ()
           (when (@ props doing-win-animation)
             (chain
              gsap
              (from-to (@ card-ref current)
                       (create
                        rotation -3)
                       (create
                        rotation 3
                        duration 0.8
                        repeat -1
                        yoyo true
                        ease "sine.inOut"
                        delay (* (card->index (@ props card)) 0.1))))
             (chain
              gsap
              (to (@ card-ref current)
                  (create
                   y 40
                   duration 1
                   repeat -1
                   yoyo true
                   ease "sine.inOut"
                   delay (* (card->index (@ props card)) 0.1)))))
           undefined)
         (with-defaults ((doing-win-animation false)) props
           (create
            revert-on-update true
            dependencies (list doing-win-animation)))))
     (_ (use-layout-effect
         (lambda ()
           (chain gsap (kill-tweens-of (@ card-ref current) "left,top,bottom"))
           (when (not (@ props being-dragged))
             (cond
               ((@ props doing-win-animation)
                (let ((idx (- (card->index (@ props card)) 5)))
                  ((@ gsap to)
                   (@ card-ref current)
                   (create
                    duration 3
                    top (when (oddp idx) 0)
                    bottom (when (evenp idx) 100)
                    left (+ (* idx 40))
                    on-complete set-z-index-boosted
                    on-complete-params (list false)))))
               ((not (null (@ props freecell)))
                (with-slots (left top)
                    (get-offset
                     (chain document
                            (get-element-by-id (+ "freecell_" (@ props freecell)))))
                  (set-z-index-boosted true)
                  ((@ gsap to)
                   (@ card-ref current)
                   (create
                    duration 0.3
                    top top
                    left left
                    bottom nil
                    on-complete set-z-index-boosted
                    on-complete-params (list false)))))
               ((not (null (@ props foundation)))
                (with-slots (left top)
                    (get-offset
                     (chain document
                            (get-element-by-id (+ "foundation_" (@ props foundation)))))
                  (set-z-index-boosted true)
                  ((@ gsap to)
                   (@ card-ref current)
                   (create
                    duration 0.3
                    top top
                    left left
                    bottom nil
                    box-shadow "none"
                    on-complete set-z-index-boosted
                    on-complete-params (list false)))))
               (t
                (set-z-index-boosted true)
                ((@ gsap to)
                 (@ card-ref current)
                 (create
                  duration 0.3
                  top (+ 180 (* (1- (@ props row))
                                50
                                (/ 9 (max 9 (1- (@ props col-count))))))
                  left (* (@ props col) 120)
                  bottom nil
                  on-complete set-z-index-boosted
                  on-complete-params (list false))))))
           undefined)
         (list (@ props row)
               (@ props col)
               (@ props being-dragged)
               (@ props freecell)
               (@ props foundation)
               (@ props doing-win-animation)
               (@ props col-count))))
     (_ (use-effect
         (lambda ()
           (when (@ props can-drag)
             (setf (@ dg current)
                   (chain draggable
                          (create (+ "#" (@ props id))
                                  (create
                                   type "left,top"

                                   z-index-boost
                                   false

                                   on-press
                                   (lambda ()
                                     (chain gsap (kill-tweens-of (@ card-ref current) "left,top,bottom"))
                                     (set-z-index-boosted true)
                                     (setf (@ start-x current) (@ this x))
                                     (setf (@ start-y current) (@ this y))
                                     (setf (@ companions current)
                                           (loop for id in (@ props lower-cards)
                                                 for el = (chain document (get-element-by-id id))
                                                 do (chain gsap (kill-tweens-of el "left,top,bottom"))
                                                 collect (create
                                                          element el
                                                          x (chain gsap (get-property el "left"))
                                                          y (chain gsap (get-property el "top")))))
                                     (unless (@ companions current length)
                                       ((@ gsap to)
                                        (@ dg current 0 target)
                                        (create
                                         duration 0.3
                                         scale 1.1
                                         rotation -3
                                         box-shadow
                                         "0px 10px 20px rgba(0,0,0,0.3)")))
                                     (chain props (on-start-drag)))

                                   on-drag
                                   (lambda ()
                                     (let ((delta-x (- (@ this x) (@ start-x current)))
                                           (delta-y (- (@ this y) (@ start-y current))))
                                       (loop for companion in (@ companions current) do
                                         ((@ gsap set)
                                          (@ companion element)
                                          (create
                                           left (+ (@ companion x) delta-x)
                                           top (+ (@ companion y) delta-y))))))

                                   on-release
                                   (lambda ()
                                     (chain props (on-end-drag))
                                     (set-z-index-boosted false)
                                     (loop for droppable in (@ props droppables) do
                                       (when (chain this (hit-test (+ "#" droppable) "25%"))
                                         ((@ on-moved-callback current) droppable)
                                         (return)))
                                     ((@ gsap to)
                                      (@ dg current 0 target)
                                      (create
                                       duration 0.3
                                       rotation 0
                                       scale 1
                                       box-shadow "0px 10px 20px rgba(0,0,0,0.1)"))))))))
           (lambda ()
             #+nil (dbg "KILLING DRAGGABLE" (@ props id))
             (when (@ dg current)
               ((@ gsap to)
                (@ dg current 0 target)
                (create
                 duration 0.3
                 rotation 0
                 scale 1
                 box-shadow "0px 10px 20px rgba(0,0,0,0.1)"))
               (chain dg current 0 (kill)))))
         ;;seriously?
         (list (chain -j-s-o-n (stringify (@ props droppables)))
               (chain -j-s-o-n (stringify (@ props lower-cards)))
               (@ props can-drag)))))
  (props)
  (setf (@ on-moved-callback current) (@ props on-moved))
  (psx
   (:div ((id (@ props id))
          (class-name "card")
          (ref card-ref)
          (style (create
                  "background-color" "white"
                  "border-radius" "7px"
                  "border" "solid"
                  "border-width" "1px"
                  "position" "absolute"
                  "pointer-events" "auto"
                  "z-index" (if (or z-index-boosted (@ props being-dragged))
                                (+ 1000
                                   (or (@ props row) 0)
                                   (if (or (@ props freecell) (@ props foundation))
                                       100
                                       0))
                                (or (@ props row) 0)))))
         (:img ((src (@ props img))
                (alt (card->name (@ props card)))
                (style (create "display" "block"))
                (width 108)
                (height 154)
                (draggable false))))))

(defcomponent -ui-button () (props)
  (with-defaults (on-click (disabled false) children) props
    (psx
     (:div ((on-click on-click)
            (class-name (class-names "ui-button" (when disabled "disabled")))
            (style (create
                    "display" "inline-block"
                    "border-radius" "7px"
                    "background-color" "white"
                    "padding" "10px"
                    "margin-right" "5px"
                    "margin-bottom" "10px"
                    "font-size" "15pt"
                    "color" (if disabled
                                "grey"
                                "black"))))
           children))))

(defun make-game-state (seed)
  (create
   tableaus (make-tableaus seed)
   freecells '(nil nil nil nil)
   foundations (list (list) (list) (list) (list))))

(defun winning-state ()
  (create
   tableaus (append (loop for i from 0 below 7
                          collect (list))
                    (list
                     (list '(spade 12) '(spade 13))))
   freecells '(nil nil nil nil)
   foundations (list
                (loop for i from 1 to 11 collect (list 'spade i))
                (loop for i from 1 to 13 collect (list 'clover i))
                (loop for i from 1 to 13 collect (list 'diamond i))
                (loop for i from 1 to 13 collect (list 'heart i)))))

(defun random-seed ()
  (chain -Math (floor (* (chain -Math (random)) 32000))))

(defcomponent -you-win
    ((_ (use-g-s-a-p
         (lambda ()
           (chain gsap
                  (from-to
                   "#you-win"
                   (create scale 0)
                   (create scale 1
                           duration 1
                           ease "back.out(4)"
                           delay 2.2)))
           (chain gsap
                  (from-to
                   "#you-win"
                   (create rotation -3)
                   (create rotation 3
                           yoyo true
                           repeat -1
                           ease "sine.inOut")))))))
  ()
  (psx
   (:div ((style (create "position" "absolute"
                         "width" "100vw"
                         "height" "100vh"
                         "left" "0"
                         "top" "0"
                         "display" "flex"
                         "align-items" "center"
                         "justify-content" "center"
                         "font-size" "100pt"
                         "color" "white"
                         "text-shadow" "4px 4px 0px black")))
         (:div ((id "you-win")) "You win!"))))

(defcomponent -cards (((seed set-seed) (use-state (random-seed) #+nil 21013))
                      ((dragged-cards set-dragged-cards) (use-state (list)))
                      (initial-board (use-memo (lambda () (make-game-state seed))
                                               (list)))
                      (board-state (use-history-state2 initial-board))
                      ((doing-win-animation set-doing-win-animation) (use-state false)))
  ()
  (with-slots (tableaus freecells foundations) (@ board-state state)
    (flet ((set-board-state (state) (chain board-state (set state)))
           (board-state () (structured-clone (@ board-state state))))
      (let ((won (= 52 (loop for foundation in foundations
                             summing (length foundation)))))
        (psx
         (when (or won doing-win-animation)
           (psx (:-you-win ())))
         (:div ((style (create "position" "absolute"
                               "width" "100vw"
                               "height" "100vh"
                               "left" "0"
                               "top" "0")))
               (:div ((style (create
                              "position" "absolute"
                              "left" "7px"
                              "bottom" "0px")))
                     (:b ()
                         (:-ui-button ((on-click (lambda ()
                                                   (let ((new-seed (random-seed)))
                                                     (set-seed new-seed)
                                                     (chain board-state (clear (make-game-state new-seed)))
                                                     (set-dragged-cards (list))
                                                     (set-doing-win-animation false)))))
                                      "New Game")
                         (:-ui-button ((on-click (lambda ()
                                                   (when (@ board-state can-undo)
                                                     (chain board-state (undo)))))
                                       (disabled (not (@ board-state can-undo))))
                                      "↩ Undo")
                         (:-ui-button ((on-click (lambda ()
                                                   (when (@ board-state can-redo)
                                                     (chain board-state (redo)))))
                                       (disabled (not (@ board-state can-redo))))
                                      "↪ Redo")
                         (:-ui-button ((on-click (lambda ()
                                                   (block func
                                                     (loop for tableau in tableaus
                                                           for card1 = (last tableau) do
                                                             (loop for tableau2 in tableaus
                                                                   for card2 = (last tableau2)
                                                                   when (suitable-droppable card1 card2) do
                                                                     (let ((id (+ "#" (card->id card1))))
                                                                       (chain gsap
                                                                              (to id
                                                                                  (/ 1 4)
                                                                                  (create y -50
                                                                                          ease "power2.out")))
                                                                       (chain gsap
                                                                              (to id
                                                                                  (/ 1 2)
                                                                                  (create y 0
                                                                                          ease "bounce.out"
                                                                                          delay (/ 1 4))))
                                                                       (return-from func))))))))
                                      "Hint")
                         (when-dev
                          (psx
                           (:-ui-button ((on-click (lambda ()
                                                     (chain board-state
                                                            (set (winning-state))))))
                                        "Debug"))))
                     (:span ((style (create color "white"
                                            "font-size" "15pt")))
                            (+ "FreeCell #" seed))))
         (:div
          ((style (create "position" "absolute"
                          "height" "100vh"
                          "pointer-events" "none")))
          (:-free-cells ())
          (:-drop-bases ())
          (let2 ((sorted-cards (list)))
                (let ((idx 0))
                  (loop for card in freecells
                        when card do
                          (destructuring-bind (suit num) card
                            (setf (aref sorted-cards (card->index card))
                                  (psx (:-card
                                        ((freecell idx)
                                         (droppables (append (loop for tableau in tableaus
                                                                   when (and (not (emptyp tableau))
                                                                             (suitable-droppable card (last tableau)))
                                                                     collect (card->id (last tableau)))
                                                             (loop for i from 0 below 4
                                                                   collect (+ "freecell_" i))
                                                             (loop for i from 0 below 8
                                                                   when (emptyp (aref tableaus i))
                                                                     collect (+ "dropbase_" i))
                                                             (loop for i from 0 below 4
                                                                   collect (+ "foundation_" i))))
                                         (card card)
                                         (id (card->id card))
                                         (key (card->id card))
                                         (can-drag true)
                                         (being-dragged (not (= (chain dragged-cards (index-of (card->id card))) -1)))

                                         (doing-win-animation (or doing-win-animation won))
                                         (lower-cards (list))
                                         (on-start-drag (lambda () (set-dragged-cards (list (card->id card)))))
                                         (on-end-drag (lambda () (set-dragged-cards (list))))
                                         (on-moved
                                          (fwrap (idx suit)
                                            (lambda (dropped-on)
                                              (cond
                                                ((chain dropped-on (includes "freecell"))
                                                 (let ((num (freecell->num dropped-on)))
                                                   (when (null (aref freecells num))
                                                     (-> (board-state)
                                                         (set-freecell num card)
                                                         (clear-freecell idx)
                                                         (auto-foundation)
                                                         (set-board-state)))))
                                                ((chain dropped-on (includes "foundation"))
                                                 (let* ((num (freecell->num dropped-on))
                                                        (foundation (aref foundations num))
                                                        (dropped-on-card (last foundation)))
                                                   (when (next-in-suit card dropped-on-card)
                                                     (-> (board-state)
                                                         (clear-freecell idx)
                                                         (insert-card 'foundations (suit->index suit) card)
                                                         (auto-foundation)
                                                         (set-board-state)))))
                                                ((chain dropped-on (includes "dropbase"))
                                                 (let ((num (freecell->num dropped-on)))
                                                   (-> (board-state)
                                                       (clear-freecell idx)
                                                       (insert-card 'tableaus num card)
                                                       (auto-foundation)
                                                       (set-board-state))))
                                                (t
                                                 (destructuring-bind
                                                     (newcol newrow)
                                                     (find-card (id->card dropped-on) tableaus)
                                                   (-> (board-state)
                                                       (clear-freecell idx)
                                                       (insert-card 'tableaus newcol card)
                                                       (auto-foundation)
                                                       (set-board-state))))))))
                                         (img (card->img card)))))))
                        do (incf idx)))
                (let ((idx 0))
                  (loop for foundation in foundations do
                    (loop for card in foundation
                          for (suit num) = card do
                            (setf (aref sorted-cards (card->index card))
                                  (psx (:-card
                                        ((foundation idx)
                                         (droppables (list))
                                         (id (card->id card))
                                         (key (card->id card))
                                         (card card)
                                         (can-drag false)
                                         (being-dragged false)
                                         (lower-cards (list))
                                         (doing-win-animation (or doing-win-animation won))
                                         (img (card->img card)))))))
                        do (incf idx)))
                (let* ((col 0) (row 1)
                       (num-empty-cascades (chain tableaus (filter #'emptyp) length))
                       (num-empty-cells (chain freecells (filter (lambda (x) (null x))) length))
                       (max-draggable (* (expt 2 num-empty-cascades)
                                         (+ num-empty-cells 1))))
                  (loop for tableau in tableaus do
                    (loop for card in tableau
                          for (suit num) = card do
                            (let ((lower-cards (chain tableau (slice row))))
                              (fwrap (col row suit num)
                                (setf (aref sorted-cards (card->index card))
                                      (psx (:-card
                                            ((col col)
                                             (row row)
                                             (col-count (length tableau))
                                             (droppables (append (loop for tableau in tableaus
                                                                       when (and (not (emptyp tableau))
                                                                                 (suitable-droppable card (last tableau)))
                                                                         collect (card->id (last tableau)))
                                                                 (loop for i from 0 below 4
                                                                       when (not (aref freecells i))
                                                                         collect (+ "freecell_" i))
                                                                 (loop for i from 0 below 8
                                                                       when (emptyp (aref tableaus i))
                                                                         collect (+ "dropbase_" i))
                                                                 (loop for i from 0 below 4
                                                                       collect (+ "foundation_" i))))
                                             (lower-cards (chain lower-cards (map #'card->id)))
                                             (id (card->id card))
                                             (key (card->id card))
                                             (card card)
                                             (can-drag (and (is-tableau (append (list card) lower-cards))
                                                            (<= (length (append (list card) lower-cards)) max-draggable)))
                                             (on-start-drag (lambda ()
                                                              (set-dragged-cards
                                                               (chain tableau (slice (1- row)) (map #'card->id)))))
                                             (on-end-drag (lambda () (set-dragged-cards (list))))
                                             (being-dragged (not (= (chain dragged-cards (index-of (card->id card))) -1)))
                                             (doing-win-animation (or doing-win-animation won))
                                             (img (card->img card))
                                             (on-moved
                                              (lambda (dropped-on)
                                                (cond
                                                  ((chain dropped-on (includes "freecell"))
                                                   (let ((num (freecell->num dropped-on)))
                                                     (when (and (null (aref freecells num))
                                                                (= 1 (@ dragged-cards length)))
                                                       (-> (board-state)
                                                           (delete-from-column col)
                                                           (set-freecell num card)
                                                           (auto-foundation)
                                                           (set-board-state)))))
                                                  ((chain dropped-on (includes "foundation"))
                                                   (let* ((num (freecell->num dropped-on))
                                                          (foundation (aref foundations num))
                                                          (dropped-on-card (last foundation)))
                                                     (when (and (= 1 (@ dragged-cards length))
                                                                (next-in-suit card dropped-on-card))
                                                       (-> (board-state)
                                                           (delete-from-column col)
                                                           (insert-card 'foundations (suit->index suit) card)
                                                           (auto-foundation)
                                                           (set-board-state)))))
                                                  ((chain dropped-on (includes "dropbase"))
                                                   (let ((num (freecell->num dropped-on)))
                                                     (-> (board-state)
                                                         (move-card col row num)
                                                         (auto-foundation)
                                                         (set-board-state))))
                                                  (t
                                                   (destructuring-bind
                                                       (newcol newrow)
                                                       (find-card (id->card dropped-on) tableaus)
                                                     (-> (board-state)
                                                         (move-card col row newcol)
                                                         (auto-foundation)
                                                         (set-board-state)))))))))))))
                          do (incf row))
                        do (incf col) (setf row 1))

                  sorted-cards))))))))

(defcomponent -free-cell ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "display" "inline-block"
                  "width" 108
                  "height" 154
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -foundation ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "display" "inline-block"
                  "width" 108
                  "height" 154
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -drop-base ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "visibility" "hidden"
                  "position" "absolute"
                  "width" 108
                  "height" 154
                  "top" (+ 130 (* 1 50))
                  "left" (* (@ props col) 120)
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -free-cells () ()
  (psx
   (:div ((style (create "white-space" "nowrap")))
         (loop for i from 0 below 4
               collect
               (psx (:-free-cell ((id (+ "freecell_" i))))))
         (psx (:div ((style (create "width" 30
                                    "margin-right" "12px"
                                    "display" "inline-block")))))
         (loop for i from 0 below 4
               collect
               (psx (:-foundation ((id (+ "foundation_" i)))))))))

(defcomponent -drop-bases () ()
  (loop for i from 0 below 8
        collect
        (psx
         (:-drop-base ((id (+ "dropbase_" i))
                       (col i))))))

(defcomponent -game () ()
  (psx
   (:-background-overlay ())
   (:-cards ())))

(defcomponent -background-overlay () ()
  (psx
   (:div ((style (create
                  position "fixed"
                  left 0
                  top 0
                  "z-index" -1
                  width "100%"
                  height "100%"
                  background-color "rgb(36, 83, 36)"
                  background-image "url(background_tile_transparent@2x.png)")))
         (:div ((style (create
                        "width" "100%"
                        "height" "100%"
                        "top" 0
                        "left" 0
                        "mix-blend-mode" "overlay"
                        "background" "-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.16) 100%,hsla(0,0%,100%,.08) 0),-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.32) 0,hsla(0,0%,100%,0) 100%),-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.32) 0,hsla(0,0%,100%,0) 64%)")))))))

(when-dev
 (chain preact (render "" (@ document body) nil))
 (var root
      (let ((-app (psx (:-game ()))))
        (chain preact (render -app (@ document body)))))

 (chain console (clear)))

(when-prod
 (let ((-app (psx (:-game ()))))
   (chain preact (hydrate -app (@ document body)))))
