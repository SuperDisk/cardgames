(defun dbg (&rest rest)
  (apply (@ console log) rest)
  (@ rest 0))

(defun make-rng (seed)
  #'(lambda ()
      (ash (setf seed (mod (+ (* 214013 seed) 2531011) (expt 2 31))) -16)))

(defmacro swap (p1 p2)
  `(setf (list ,p1 ,p2) (list ,p2 ,p1)))

(defmacro -> (initial &rest forms)
  (if (null forms)
      initial
      `(-> ,(list* (caar forms) initial (cdar forms))
           ,@(cdr forms))))

(defun new-deck (seed)
  (let ((hand (list))
        (rng (make-rng seed)))
    (dolist (d (loop for i from 1 to 13 collect i))
      (dolist (s '(clover diamond heart spade))
        (chain hand (push (list s d)))))
    (dotimes (i 52)
      (let ((idx1 (- 51 i))
            (idx2 (mod (funcall rng) (- 52 i)))))
      (swap (aref hand idx1)
            (aref hand idx2)))
    (chain hand (reverse))))

(defun last (list)
  (aref list (1- (@ list length))))

(defun make-tableaus (seed)
  (let ((deck (new-deck seed))
        (tableaus (loop for i from 0 below 8 collect (list))))
    (loop for i from 0 to 51
          for card in deck do
            (chain (aref tableaus (mod i 8)) (push card)))
    tableaus))

(defun suit->index (suit)
  (case suit
    ((spade) 0)
    ((clover) 1)
    ((heart) 2)
    ((diamond) 3)))

(defun card->index (card)
  (destructuring-bind (suit num) card
    (+ num (* 13 (suit->index suit)))))

(defun card->id (card)
  (destructuring-bind (suit num) card
    (+ "card_" suit "_" num)))

(defun card->img (card)
  (destructuring-bind (suit num) card
    (+ "src/assets/newcards/" suit "_" num ".svg")))

(defun id->card (id)
  (let ((parts (chain id (split "_"))))
    (list (aref parts 1)
          (parse-int (aref parts 2)))))

(defun freecell->num (id)
  (aref (chain id (split "_")) 1))

(defun card= (card1 card2)
  (and (equal (aref card1 0) (aref card2 0))
       (equal (aref card1 1) (aref card2 1))))

(defun find-card (card tableaus)
  (let ((col 0) (row 0))
    (loop for tableau in tableaus do
      (loop for maybe-card in tableau
            when (card= card maybe-card)
              do (return-from find-card (list col row))
            do (incf row))
      (incf col)
      (setf row 0))))

;;;;;;;;;;;;;

(defun move-card (state from row to)
  (let* ((tableaus (@ state tableaus))
         (before (chain (aref tableaus from) (slice 0 (1- row))))
         (after (chain (aref tableaus from) (slice (1- row)))))
    (setf (aref tableaus from) before)
    (setf (aref tableaus to) (append (aref tableaus to) after))
    state))

(defun insert-card (state arr into card)
  (let* ((tableaus (aref state arr)))
    (chain (aref tableaus into) (push card))
    state))

(defun delete-from-column (state from)
  (let ((tableaus (@ state tableaus)))
    (chain (aref tableaus from) (pop))
    state))

(defun set-freecell (state idx card)
  (let ((freecells (@ state freecells)))
    (setf (aref freecells idx) card)
    state))

(defun clear-freecell (state idx)
  (let ((freecells (@ state freecells)))
    (setf (aref freecells idx) nil)
    state))

(defun auto-foundation (state)
  (flet ((find-ready ()
             (with-slots (tableaus foundations) state
               (loop for tableau in tableaus
                     for col = 0 then (1+ col)
                     for card = (last tableau)
                     when card
                       do
                          (destructuring-bind (suit num) card
                            (let* ((suit-idx (suit->index suit))
                                   (dropped-on-card (last (aref foundations suit-idx))))
                              (when (next-in-suit card dropped-on-card)
                                (-> state
                                    (delete-from-column col)
                                    (insert-card 'foundations suit-idx card))
                                (return-from find-ready true)))))

               (loop for card in freecells
                     for cell-idx = 0 then (1+ cell-idx)
                     when card do
                       (destructuring-bind (suit num) card
                         (let* ((suit-idx (suit->index suit))
                                (dropped-on-card (last (aref foundations suit-idx))))
                           (when (next-in-suit card dropped-on-card)
                             (-> state
                                 (clear-freecell cell-idx)
                                 (insert-card 'foundations suit-idx card))
                             (return-from find-ready true))))))
             false)))
  (loop while (find-ready))

  state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun without-idx (list idx)
  (chain list (filter (lambda (val arr-idx) (not (= idx arr-idx))))))

(defun emptyp (list)
  (not (@ list length)))

(defun suit-color (suit)
  (case suit
    ((diamond) 'red)
    ((heart) 'red)
    ((spade) 'black)
    ((clover) 'black)))

(defun suitable-droppable (card droppable)
  (destructuring-binds (((suit1 num1) card)
                        ((suit2 num2) droppable))
                       (and (not (= (suit-color suit1) (suit-color suit2)))
                            (= (1- num2) num1))))

(defun next-in-suit (card next)
  (if (not next)
      (= (aref card 1) 1)
      (destructuring-bind (suit1 num1) card
        (destructuring-bind (suit2 num2) next
          (and (= suit1 suit2) (= (1- num1) num2))))))

(defun is-tableau (cards)
  (loop for (c1 c2) on cards
        when (and c2 (not (suitable-droppable c2 c1))) do (return false)
          finally (return true)))

(defun obj+= (obj1 obj2)
  (chain -Object (assign obj1 obj2)))

(defcomponent -card
    ((dg (use-ref))
     (card-ref (use-ref))
     (companions (use-ref))
     (start-x (use-ref))
     (start-y (use-ref))
     (on-moved-callback (use-ref))
     ((z-index-boosted set-z-index-boosted) (use-state
                                             (lambda ()
                                               (dbg "REMOUNTING CARD")
                                               false)))
     (_ (use-effect
         (lambda ()
           (when (not (@ props being-dragged))
             (cond
               ((not (null (@ props freecell)))
                (with-slots (left top)
                    (chain document
                           (get-element-by-id (+ "freecell_" (@ props freecell)))
                           (get-bounding-client-rect))
                  ((@ gsap to)
                   (@ card-ref current)
                   (create
                    duration 0.3
                    top top
                    left left))))
               ((not (null (@ props foundation)))
                (with-slots (left top)
                    (chain document
                           (get-element-by-id (+ "foundation_" (@ props foundation)))
                           (get-bounding-client-rect))
                  ((@ gsap to)
                   (@ card-ref current)
                   (create
                    duration 0.3
                    top top
                    left left
                    box-shadow "none"))))
               (t
                ((@ gsap to)
                 (@ card-ref current)
                 (create
                  duration 0.3
                  top (+ 130 (* (@ props row) 50))
                  left (* (@ props col) 120)))))))
         (list (@ props row) (@ props col) (@ props being-dragged) (@ props freecell) (@ props foundation))))
     (_ (use-effect
         (lambda ()
           (when (@ props can-drag)
             (setf (@ dg current)
                   (chain draggable
                          (create (+ "#" (@ props id))
                                  (create
                                   type "left,top"

                                   z-index-boost
                                   false

                                   on-press
                                   (lambda ()
                                     (chain gsap (kill-tweens-of (@ card-ref current)))
                                     (set-z-index-boosted true)
                                     (setf (@ start-x current) (@ this x))
                                     (setf (@ start-y current) (@ this y))
                                     (setf (@ companions current)
                                           (loop for id in (@ props lower-cards)
                                                 for el = (chain document (get-element-by-id id))
                                                 do (chain gsap (kill-tweens-of el))
                                                 collect (create
                                                          element el
                                                          x (chain gsap (get-property el "left"))
                                                          y (chain gsap (get-property el "top")))))
                                     (unless (@ companions current length)
                                       ((@ gsap to)
                                        (@ dg current 0 target)
                                        (create
                                         duration 0.3
                                         scale 1.1
                                         rotation -3
                                         box-shadow
                                         "0px 10px 20px rgba(0,0,0,0.3)")))
                                     (chain props (on-start-drag)))

                                   on-drag
                                   (lambda ()
                                     (let ((delta-x (- (@ this x) (@ start-x current)))
                                           (delta-y (- (@ this y) (@ start-y current))))
                                       (loop for companion in (@ companions current) do
                                         ((@ gsap set)
                                          (@ companion element)
                                          (create
                                           left (+ (@ companion x) delta-x)
                                           top (+ (@ companion y) delta-y))))))

                                   on-release
                                   (lambda ()
                                     (chain props (on-end-drag))
                                     (set-z-index-boosted false)
                                     (loop for droppable in (@ props droppables) do
                                       (when (chain this (hit-test (+ "#" droppable) "25%"))
                                         ((@ on-moved-callback current) droppable)
                                         (return)))
                                     ((@ gsap to)
                                      (@ dg current 0 target)
                                      (create
                                       duration 0.3
                                       rotation 0
                                       scale 1
                                       box-shadow "0px 10px 20px rgba(0,0,0,0.1)"))))))))
           (lambda ()
             (dbg "KILLING DRAGGABLE")
             (when (@ dg current)
               (chain dg current 0 (kill)))))
         ;;seriously?
         (list (chain -j-s-o-n (stringify (@ props droppables)))
               (chain -j-s-o-n (stringify (@ props lower-cards)))
               (@ props can-drag)))))
  (props)
  (setf (@ on-moved-callback current) (@ props on-moved))
  (psx
   (:div ((id (@ props id))
          (ref card-ref)
          (style (create
                  "background-color" "white"
                  "border-radius" "7px"
                  "border" "solid"
                  "border-width" "1px"
                  "position" "absolute"
                  "z-index" (if (or z-index-boosted (@ props being-dragged))
                                (+ 1000 (or (@ props row) 0))
                                (or (@ props row) 0)))))
         (:img ((src (@ props img))
                (width 108)
                (height 154)
                (draggable false))))))

(defcomponent -cards (((dragged-cards set-dragged-cards) (use-state (list)))
                      (initial-board (use-memo (lambda ()
                                                 (create
                                                  tableaus (make-tableaus 21013)
                                                  freecells '(nil nil nil nil)
                                                  foundations (list (list) (list) (list) (list))))
                                               (list)))
                      (board-state
                       (use-history-state initial-board)))
  ()
  (with-slots (tableaus freecells foundations) (@ board-state state)
    (flet ((set-board-state (state) (chain board-state (set state)))
           (board-state () (structured-clone (@ board-state state))))
      (psx
       (:button ((onclick (lambda () (chain board-state (undo))))) "Undo")
       (let ((sorted-cards (list)))
         (let ((idx 0))
           (loop for card in freecells
                 when card do
                   (destructuring-bind (suit num) card
                     (setf (aref sorted-cards (card->index card))
                           (psx (:-card
                                 ((freecell idx)
                                  (droppables (append (loop for tableau in tableaus
                                                            when (and (not (emptyp tableau))
                                                                      (suitable-droppable card (last tableau)))
                                                              collect (card->id (last tableau)))
                                                      (loop for i from 0 below 4
                                                            collect (+ "freecell_" i))
                                                      (loop for i from 0 below 8
                                                            when (emptyp (aref tableaus i))
                                                              collect (+ "dropbase_" i))
                                                      (loop for i from 0 below 4
                                                            collect (+ "foundation_" i))))
                                  (id (card->id card))
                                  (key (card->id card))
                                  (can-drag true)
                                  (being-dragged (not (= (chain dragged-cards (index-of (card->id card))) -1)))
                                  (lower-cards (list))
                                  (on-start-drag (lambda () (set-dragged-cards (list (card->id card)))))
                                  (on-end-drag (lambda () (set-dragged-cards (list))))
                                  (on-moved
                                   (fwrap (idx suit)
                                     (lambda (dropped-on)
                                       (cond
                                         ((chain dropped-on (includes "freecell"))
                                          (let ((num (freecell->num dropped-on)))
                                            (when (null (aref freecells num))
                                              (-> (board-state)
                                                  (set-freecell num card)
                                                  (clear-freecell idx)
                                                  (auto-foundation)
                                                  (set-board-state)))))
                                         ((chain dropped-on (includes "foundation"))
                                          (let* ((num (freecell->num dropped-on))
                                                 (foundation (aref foundations num))
                                                 (dropped-on-card (last foundation)))
                                            (when (next-in-suit card dropped-on-card)
                                              (-> (board-state)
                                                  (clear-freecell idx)
                                                  (insert-card 'foundations (suit->index suit) card)
                                                  (auto-foundation)
                                                  (set-board-state)))))
                                         ((chain dropped-on (includes "dropbase"))
                                          (let ((num (freecell->num dropped-on)))
                                            (-> (board-state)
                                                (clear-freecell idx)
                                                (insert-card 'tableaus num card)
                                                (auto-foundation)
                                                (set-board-state))))
                                         (t
                                          (destructuring-bind
                                              (newcol newrow)
                                              (find-card (id->card dropped-on) tableaus)
                                            (-> (board-state)
                                                (clear-freecell idx)
                                                (insert-card 'tableaus newcol card)
                                                (auto-foundation)
                                                (set-board-state))))))))
                                  (img (card->img card)))))))
                 do (incf idx)))
         (let ((idx 0))
           (loop for foundation in foundations do
             (loop for card in foundation
                   for (suit num) = card do
                     (setf (aref sorted-cards (card->index card))
                           (psx (:-card
                                 ((foundation idx)
                                  (droppables (list))
                                  (id (card->id card))
                                  (key (card->id card))
                                  (can-drag false)
                                  (being-dragged false)
                                  (lower-cards (list))
                                  (img (card->img card)))))))
                 do (incf idx)))
         (let* ((col 0) (row 1)
                (num-empty-cascades (chain tableaus (filter #'emptyp) length))
                (num-empty-cells (chain freecells (filter (lambda (x) (null x))) length))
                (max-draggable (* (expt 2 num-empty-cascades)
                                  (+ num-empty-cells 1))))
           (loop for tableau in tableaus do
             (loop for card in tableau
                   for (suit num) = card do
                     (let ((lower-cards (chain tableau (slice row))))
                       (fwrap (col row suit num)
                         (setf (aref sorted-cards (card->index card))
                               (psx (:-card
                                     ((col col)
                                      (row row)
                                      (droppables (append (loop for tableau in tableaus
                                                                when (and (not (emptyp tableau))
                                                                          (suitable-droppable card (last tableau)))
                                                                  collect (card->id (last tableau)))
                                                          (loop for i from 0 below 4
                                                                when (not (aref freecells i))
                                                                  collect (+ "freecell_" i))
                                                          (loop for i from 0 below 8
                                                                when (emptyp (aref tableaus i))
                                                                  collect (+ "dropbase_" i))
                                                          (loop for i from 0 below 4
                                                                collect (+ "foundation_" i))))
                                      (lower-cards (chain lower-cards (map #'card->id)))
                                      (id (card->id card))
                                      (key (card->id card))
                                      (can-drag (and (is-tableau (append (list card) lower-cards))
                                                     (<= (length (append (list card) lower-cards)) max-draggable)))
                                      (on-start-drag (lambda ()
                                                       (set-dragged-cards
                                                        (chain tableau (slice (1- row)) (map #'card->id)))))
                                      (on-end-drag (lambda () (set-dragged-cards (list))))
                                      (being-dragged (not (= (chain dragged-cards (index-of (card->id card))) -1)))
                                      (img (card->img card))
                                      (on-moved
                                       (lambda (dropped-on)
                                         (cond
                                           ((chain dropped-on (includes "freecell"))
                                            (let ((num (freecell->num dropped-on)))
                                              (when (and (null (aref freecells num))
                                                         (= 1 (@ dragged-cards length)))
                                                (-> (board-state)
                                                    (delete-from-column col)
                                                    (set-freecell num card)
                                                    (auto-foundation)
                                                    (set-board-state)))))
                                           ((chain dropped-on (includes "foundation"))
                                            (let* ((num (freecell->num dropped-on))
                                                   (foundation (aref foundations num))
                                                   (dropped-on-card (last foundation)))
                                              (when (and (= 1 (@ dragged-cards length))
                                                         (next-in-suit card dropped-on-card))
                                                (-> (board-state)
                                                    (delete-from-column col)
                                                    (insert-card 'foundations (suit->index suit) card)
                                                    (auto-foundation)
                                                    (set-board-state)))))
                                           ((chain dropped-on (includes "dropbase"))
                                            (let ((num (freecell->num dropped-on)))
                                              (-> (board-state)
                                                  (move-card col row num)
                                                  (auto-foundation)
                                                  (set-board-state))))
                                           (t
                                            (destructuring-bind
                                                (newcol newrow)
                                                (find-card (id->card dropped-on) tableaus)
                                              (-> (board-state)
                                                  (move-card col row newcol)
                                                  (auto-foundation)
                                                  (set-board-state)))))))))))))
                   do (incf row))
                 do (incf col) (setf row 1))

           sorted-cards))))))

(defcomponent -free-cell ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "display" "inline-block"
                  "width" 108
                  "height" 154
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -foundation ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "display" "inline-block"
                  "width" 108
                  "height" 154
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -drop-base ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "position" "absolute"
                  "width" 108
                  "height" 154
                  "top" (+ 130 (* 1 50))
                  "left" (* (@ props col) 120)
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -free-cells () ()
  (psx
   (:div ((style (create "white-space" "nowrap")))
         (loop for i from 0 below 4
               collect
               (psx (:-free-cell ((id (+ "freecell_" i))))))
         (psx (:div ((style (create "width" 30
                                    "margin-right" "12px"
                                    "display" "inline-block")))))
         (loop for i from 0 below 4
               collect
               (psx (:-foundation ((id (+ "foundation_" i)))))))))

(defcomponent -drop-bases () ()
  (loop for i from 0 below 8
        collect
        (psx
         (:-drop-base ((id (+ "dropbase_" i))
                       (col i))))))

(defcomponent -game () ()
  (psx
   (:-free-cells ())
   (:-cards ())
   (:-background-overlay ())
   (:-drop-bases ())))

(defcomponent -background-overlay () ()
  (psx
   (:div ((style (create
                  position "absolute"
                  left 0
                  top 0
                  "z-index" -1
                  width "100vw"
                  height "100vh"
                  background-color "rgb(36, 83, 36)"
                  background-image "url(src/assets/background_tile_transparent@2x.png)")))
         (:div ((style (create
                        "width" "100%"
                        "height" "100%"
                        "top" 0
                        "left" 0
                        "mix-blend-mode" "overlay"
                        "background" "-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.16) 100%,hsla(0,0%,100%,.08) 0),-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.32) 0,hsla(0,0%,100%,0) 100%),-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.32) 0,hsla(0,0%,100%,0) 64%)")))))))

((@ preact render) "" (@ document body) nil)
(var root
     (let ((-app (psx (:-game ()))))
       ((@ preact render) -app (@ document body))))

(chain console (clear))
