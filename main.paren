(defun dbg (&rest rest)
  (apply (@ console log) rest)
  (@ rest 0))

(defun last (list)
  (aref list (1- (@ list length))))

(defun shuffle-array (array)
  (loop for i from (1- (@ array length)) above 0 do
    (let* ((j ((@ -Math floor) (* (chain -Math (random)) (1+ i))))
           (temp (aref array i)))
      (setf (aref array i) (aref array j))
      (setf (aref array j) temp)))
  array)

(defun new-deck ()
  (shuffle-array
   (loop for suit in '(spade heart clover diamond)
         append
         (loop for num from 1 to 13
               collect (list suit num)))))

(defun subseq (list start &optional end)
  (let ((end (or end (@ list length))))
    (chain list (slice start end))))

(defun make-tableaus ()
  (let* ((deck (new-deck)))
    (flet ((take (n)
             (prog1
                 (subseq deck 0 n)
               (setf deck (subseq deck n)))))
      (list (take 7) (take 7) (take 7) (take 7)
            (take 6) (take 6) (take 6) (take 6)))))

(defun card->index (card)
  (destructuring-bind (suit num) card
    (+ num
       (* 13
          (case suit
            ((spade) 0)
            ((clover) 1)
            ((heart) 2)
            ((diamond) 3))))))

(defun card->id (card)
  (destructuring-bind (suit num) card
    (+ "card_" suit "_" num)))

(defun id->card (id)
  (let ((parts (chain id (split "_"))))
    (list (aref parts 1)
          (parse-int (aref parts 2)))))

(defun freecell->num (id)
  (aref (chain id (split "_")) 1))

(defun card= (card1 card2)
  (and (equal (aref card1 0) (aref card2 0))
       (equal (aref card1 1) (aref card2 1))))

(defun find-card (card tableaus)
  (let ((col 0) (row 0))
    (loop for tableau in tableaus do
      (loop for maybe-card in tableau
            when (card= card maybe-card)
              do (return-from find-card (list col row))
            do (incf row))
      (incf col)
      (setf row 0))))

(defun move-card (tableau from row to)
  (let* ((tableau (structured-clone tableau))
         (before (chain (aref tableau from) (slice 0 (1- row))) "before")
         (after (chain (aref tableau from) (slice (1- row))) "after"))
    (setf (aref tableau from) before)
    (setf (aref tableau to) (append (aref tableau to) after))
    tableau))

(defun insert-card (tableau into card)
  (let* ((tableau (structured-clone tableau)))
    (chain (aref tableau into) (push card))
    tableau))

(defun delete-from-column (tableau from)
  (let ((tableau (structured-clone tableau)))
    (chain (aref tableau from) (pop))
    tableau))

(defun set-freecell (freecells idx card)
  (let ((freecells (structured-clone freecells)))
    (setf (aref freecells idx) card)
    freecells))

(defun clear-freecell (freecells idx)
  (let ((freecells (structured-clone freecells)))
    (setf (aref freecells idx) nil)
    freecells))

(defun without-idx (list idx)
  (chain list (filter (lambda (val arr-idx) (not (= idx arr-idx))))))

(defun emptyp (list)
  (not (@ list length)))

(defun suit-color (suit)
  (case suit
    ((diamond) 'red)
    ((heart) 'red)
    ((spade) 'black)
    ((clover) 'black)))

(defun suitable-droppable (card droppable)
  (destructuring-binds (((suit1 num1) card)
                        ((suit2 num2) droppable))
                       (and (not (= (suit-color suit1) (suit-color suit2)))
                            (= (1- num2) num1))))

(defun is-tableau (cards)
  (loop for (c1 c2) on cards
        when (and c2 (not (suitable-droppable c2 c1))) do (return false)
          finally (return true)))

(defcomponent -card ((dg (use-ref))
                     (card-ref (use-ref))
                     (companions (use-ref))
                     (start-x (use-ref))
                     (start-y (use-ref))
                     (on-moved-callback (use-ref))
                     ((z-index-boosted set-z-index-boosted) (use-state
                                                             (lambda ()
                                                               (dbg "REMOUNTING CARD")
                                                               false)))
                     (_ (use-effect
                         (lambda ()
                           (when (not (@ props being-dragged))
                             (if (not (null (@ props freecell)))
                                 (with-slots (left top) (chain document
                                                               (get-element-by-id (+ "freecell_" (@ props freecell)))
                                                               (get-bounding-client-rect))
                                   ((@ gsap to)
                                    (@ card-ref current)
                                    (create
                                     duration 0.3
                                     top top
                                     left left)))
                                 ((@ gsap to)
                                  (@ card-ref current)
                                  (create
                                   duration 0.3
                                   top (+ 130 (* (@ props row) 50))
                                   left (* (@ props col) 120))))))
                         (list (@ props row) (@ props col) (@ props being-dragged))))
                     (_ (use-effect
                         (lambda ()
                           (when (@ props can-drag)
                             (setf (@ dg current)
                                   (chain draggable
                                          (create (+ "#" (@ props id))
                                                  (create
                                                   type "left,top"

                                                   z-index-boost
                                                   false

                                                   on-press
                                                   (lambda ()
                                                     (chain gsap (kill-tweens-of (@ card-ref current)))
                                                     (set-z-index-boosted true)
                                                     (setf (@ start-x current) (@ this x))
                                                     (setf (@ start-y current) (@ this y))
                                                     (setf (@ companions current)
                                                           (loop for id in (@ props lower-cards)
                                                                 for el = (chain document (get-element-by-id id))
                                                                 do (chain gsap (kill-tweens-of el))
                                                                 collect (create
                                                                          element el
                                                                          x (chain gsap (get-property el "left"))
                                                                          y (chain gsap (get-property el "top")))))
                                                     (unless (@ companions current length)
                                                       ((@ gsap to)
                                                        (@ dg current 0 target)
                                                        (create
                                                         duration 0.3
                                                         scale 1.1
                                                         rotation -3
                                                         box-shadow
                                                         "0px 10px 20px rgba(0,0,0,0.3)")))
                                                     (chain props (on-start-drag)))

                                                   on-drag
                                                   (lambda ()
                                                     (let ((delta-x (- (@ this x) (@ start-x current)))
                                                           (delta-y (- (@ this y) (@ start-y current))))
                                                       (loop for companion in (@ companions current) do
                                                         ((@ gsap set)
                                                          (@ companion element)
                                                          (create
                                                           left (+ (@ companion x) delta-x)
                                                           top (+ (@ companion y) delta-y))))))

                                                   on-release
                                                   (lambda ()
                                                     (chain props (on-end-drag))
                                                     (set-z-index-boosted false)
                                                     (loop for droppable in (@ props droppables)
                                                           do
                                                              (when (chain this (hit-test (+ "#" droppable) "25%"))
                                                                ((@ on-moved-callback current) droppable)
                                                                (return)))
                                                     ((@ gsap to)
                                                      (@ dg current 0 target)
                                                      (create
                                                       duration 0.3
                                                       rotation 0
                                                       scale 1
                                                       box-shadow "0px 10px 20px rgba(0,0,0,0.1)"))))))))
                           (lambda ()
                             (dbg "KILLING DRAGGABLE")
                             (when (@ dg current)
                               (chain dg current 0 (kill)))))
                         ;;seriously?
                         (list (chain -j-s-o-n (stringify (@ props droppables)))
                               (chain -j-s-o-n (stringify (@ props lower-cards)))
                               (@ props can-drag)))))
  (props)
  (setf (@ on-moved-callback current) (@ props on-moved))
  (psx
   (:div ((id (@ props id))
          (ref card-ref)
          (style (create
                  "background-color" "white"
                  "border-radius" "7px"
                  "border" "solid"
                  "border-width" "1px"
                  "position" "absolute"
                  "transform" (if (and (@ props can-drag)
                                       (> (@ (@ props droppables) length) 4))
                                  "rotate(10deg)")
                  "z-index" (if (or z-index-boosted (@ props being-dragged))
                                (+ 1000 (or (@ props row) 0))
                                (or (@ props row) 0)))))
         (:img ((src (@ props img)))))))

(defcomponent -cards (((tableaus set-tableaus) (use-state make-tableaus))
                      ((freecells set-freecells) (use-state '(nil nil nil nil)))
                      ((foundations set-foundations) (use-state '(nil nil nil nil)))
                      ((dragged-cards set-dragged-cards) (use-state (list))))
  ()
  (psx
   (let ((sorted-cards (list)))
     (let ((idx 0))
       (loop for card in freecells
             when card do
               (destructuring-bind (suit num) card
                 (setf (aref sorted-cards (card->index card))
                       (psx (:-card
                             ((freecell idx)
                              (droppables (append (loop for tableau in tableaus
                                                        when (suitable-droppable card (last tableau))
                                                          collect (card->id (last tableau)))
                                                  (loop for i from 0 below 4
                                                        collect (+ "freecell_" i))))
                              (id (card->id card))
                              (key (card->id card))
                              (can-drag true)
                              (being-dragged (not (= (chain dragged-cards (index-of (card->id card))) -1)))
                              (lower-cards (list))
                              (on-start-drag (lambda () (set-dragged-cards (list (card->id card)))))
                              (on-end-drag (lambda () (set-dragged-cards (list))))
                              (on-moved
                               (fwrap (idx)
                                 (lambda (dropped-on)
                                   (cond
                                     ((chain dropped-on (includes "freecell"))
                                      (let ((num (freecell->num dropped-on)))
                                        (when (null (aref freecells num))
                                          (set-freecells
                                           (clear-freecell
                                            (set-freecell freecells num card)
                                            idx)))))
                                     ((chain dropped-on (includes "foundation")))
                                     (t
                                      (destructuring-bind
                                          (newcol newrow)
                                          (find-card (id->card dropped-on) tableaus)
                                        (set-freecells (clear-freecell freecells idx))
                                        (set-tableaus (insert-card tableaus newcol card))))))))
                              (img (+ "src/assets/1_" suit "_" num "@1x.png")))))))
             do (incf idx)))
     (let ((col 0) (row 1))
       (loop for tableau in tableaus do
         (loop for card in tableau
               for (suit num) = card do
                 (let ((lower-cards (chain tableau (slice row))))
                   (fwrap (col row)
                     (setf (aref sorted-cards (card->index card))
                           (psx (:-card
                                 ((col col)
                                  (row row)
                                  (droppables (append (loop for tableau in tableaus
                                                            when (suitable-droppable card (last tableau))
                                                              collect (card->id (last tableau)))
                                                      (loop for i from 0 below 4
                                                            collect (+ "freecell_" i))))
                                  (lower-cards (chain lower-cards (map #'card->id)))
                                  (id (card->id card))
                                  (key (card->id card))
                                  (can-drag (is-tableau (append (list card) lower-cards)))
                                  (on-start-drag (lambda ()
                                                   (set-dragged-cards
                                                    (chain tableau (slice (1- row)) (map #'card->id)))))
                                  (on-end-drag (lambda () (set-dragged-cards (list))))
                                  (being-dragged (not (= (chain dragged-cards (index-of (card->id card))) -1)))
                                  (img (+ "src/assets/1_" suit "_" num "@1x.png"))
                                  (on-moved
                                   (lambda (dropped-on)
                                     (cond
                                       ((and (chain dropped-on (includes "freecell"))
                                             (= 1 (@ dragged-cards length)))
                                        (let ((num (freecell->num dropped-on)))
                                          (when (null (aref freecells num))
                                            (set-tableaus (delete-from-column tableaus col))
                                            (set-freecells (set-freecell freecells num card)))))
                                       ((chain dropped-on (includes "foundation")))
                                       (t
                                        (destructuring-bind
                                            (newcol newrow)
                                            (find-card (id->card dropped-on) tableaus)
                                          (let ((new-tableaus (move-card tableaus col row newcol)))
                                            (set-tableaus new-tableaus)))))))))))))
               do (incf row))
             do (incf col) (setf row 1))

       sorted-cards))))

(defcomponent -free-cell ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "display" "inline-block"
                  "width" 108
                  "height" 154
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -foundation ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "display" "inline-block"
                  "width" 108
                  "height" 154
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -drop-base ()
  (props)
  (psx
   (:div ((id (@ props id))
          (style (create
                  "position" "absolute"
                  "width" 108
                  "height" 154
                  "top" (* 1 50)
                  "left" (* (@ props col) 120)
                  "background-color" "white"
                  "opacity" "0.25"
                  "border-radius" "7px"
                  "margin-right" "12px"))))))

(defcomponent -free-cells () ()
  (psx
   (:div ((style (create "white-space" "nowrap")))
         (loop for i from 0 below 4
               collect
               (psx (:-free-cell ((id (+ "freecell_" i))))))
         (psx (:div ((style (create "width" 30
                                    "margin-right" "12px"
                                    "display" "inline-block")))))
         (loop for i from 0 below 4
               collect
               (psx (:-foundation ((id (+ "foundation_" i)))))))))

(defcomponent -game () ()
  (psx
   (:-free-cells ())
   (:-cards ())
   (:-background-overlay ())
   #+nil (loop for i from 0 below 8
         collect
         (psx
          (:-drop-base ((col i) (row 1)))))))

(defcomponent -background-overlay () ()
  (psx
   (:div ((style (create
                  position "absolute"
                  left 0
                  top 0
                  "z-index" -1
                  width "100vw"
                  height "100vh"
                  background-color "rgb(36, 83, 36)"
                  background-image "url(src/assets/background_tile_transparent@2x.png)")))
         (:div ((style (create
                        "width" "100%"
                        "height" "100%"
                        "top" 0
                        "left" 0
                        "mix-blend-mode" "overlay"
                        "background" "-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.16) 100%,hsla(0,0%,100%,.08) 0),-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.32) 0,hsla(0,0%,100%,0) 100%),-webkit-radial-gradient(top,ellipse farthest-corner,hsla(0,0%,100%,.32) 0,hsla(0,0%,100%,0) 64%)")))))))

((@ preact render) "" (@ document body) nil)
(var root
     (let ((-app (psx (:-game ()))))
       ((@ preact render) -app (@ document body))))
